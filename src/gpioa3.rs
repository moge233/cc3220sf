#[doc = r"Register block"]
#[repr(C)]
pub struct RegisterBlock {
    #[doc = "0x00 - 0x4000 5000 0x4000 6000 0x4000 7000 0x4002 4000 GPIO Data (GPIODATA)@@ offset 0x000 The GPIODATA register is the data register. In software control mode@@ values written in the GPIODATA register are transferred onto the GPIO port pins if the respective pins have been configured as outputs through the GPIO Direction (GPIODIR) register (see page 653). In order to write to GPIODATA@@ the corresponding bits in the mask@@ resulting from the address bus bits \\[9:2\\]@@ must be set. Otherwise@@ the bit values remain unchanged by the write. Similarly@@ the values read from this register are determined for each bit by the mask bit derived from the address used to access the data register@@ bits \\[9:2\\]. Bits that are set in the address mask cause the corresponding bits in GPIODATA to be read@@ and bits that are clear in the address mask cause the corresponding bits in GPIODATA to be read as 0@@ regardless of their value. A read from GPIODATA returns the last bit value written if the respective pins are configured as outputs@@ or it returns the value on the corresponding input pin when these are configured as inputs. All bits are cleared by a reset."]
    pub data: DATA,
    _reserved1: [u8; 1020usize],
    #[doc = "0x400 - 0x4000 5400 0x4000 6400 0x4000 7400 0x4002 4400 GPIO Direction (GPIODIR)@@ offset 0x400 The GPIODIR register is the data direction register. Setting a bit in the GPIODIR register configures the corresponding pin to be an output@@ while clearing a bit configures the corresponding pin to be an input. All bits are cleared by a reset@@ meaning all GPIO pins are inputs by default."]
    pub dir: DIR,
    #[doc = "0x404 - 0x4000 5404 0x4000 6404 0x4000 7404 0x4002 4404 GPIO Interrupt Sense (GPIOIS)@@ offset 0x404 The GPIOIS register is the interrupt sense register. Setting a bit in the GPIOIS register configures the corresponding pin to detect levels@@ while clearing a bit configures the corresponding pin to detect edges. All bits are cleared by a reset."]
    pub is: IS,
    #[doc = "0x408 - 0x4000 5408 0x4000 6408 0x4000 7408 0x4002 4408 GPIO Interrupt Both Edges (GPIOIBE)@@ offset 0x408 The GPIOIBE register allows both edges to cause interrupts. When the corresponding bit in the GPIO Interrupt Sense (GPIOIS) register is set to detect edges@@ setting a bit in the GPIOIBE register configures the corresponding pin to detect both rising and falling edges@@ regardless of the corresponding bit in the GPIO Interrupt Event (GPIOIEV) register . Clearing a bit configures the pin to be controlled by the GPIOIEV register. All bits are cleared by a reset."]
    pub ibe: IBE,
    #[doc = "0x40c - 0x4000 540C 0x4000 640C 0x4000 740C 0x4002 440C GPIO Interrupt Event (GPIOIEV)@@ offset 0x40C The GPIOIEV register is the interrupt event register. Setting a bit in the GPIOIEV register configures the corresponding pin to detect rising edges or high levels@@ depending on the corresponding bit value in the GPIO Interrupt Sense (GPIOIS) register . Clearing a bit configures the pin to detect falling edges or low levels@@ depending on the corresponding bit value in the GPIOIS register. All bits are cleared by a reset."]
    pub iev: IEV,
    #[doc = "0x410 - 0x4000 5410 0x4000 6410 0x4000 7410 0x4002 4410 GPIO Interrupt Mask (GPIOIM)@@ offset 0x410 The GPIOIM register is the interrupt mask register. Setting a bit in the GPIOIM register allows interrupts that are generated by the corresponding pin to be sent to the interrupt controller on the combined interrupt signal. Clearing a bit prevents an interrupt on the corresponding pin from being sent to the interrupt controller. All bits are cleared by a reset."]
    pub im: IM,
    #[doc = "0x414 - 0x4000 5414 0x4000 6414 0x4000 7414 0x4002 4414 GPIO Raw Interrupt Status (GPIORIS)@@ offset 0x414 The GPIORIS register is the raw interrupt status register. A bit in this register is set when an interrupt condition occurs on the corresponding GPIO pin. If the corresponding bit in the GPIO Interrupt Mask (GPIOIM) register is set@@ the interrupt is sent to the interrupt controller. Bits read as zero indicate that corresponding input pins have not initiated an interrupt. A bit in this register can be cleared by writing a 1 to the corresponding bit in the GPIO Interrupt Clear (GPIOICR) register."]
    pub ris: RIS,
    #[doc = "0x418 - 0x4000 5418 0x4000 6418 0x4000 7418 0x4002 4418 GPIO Masked Interrupt Status (GPIOMIS)@@ offset 0x418 The GPIOMIS register is the masked interrupt status register. If a bit is set in this register@@ the corresponding interrupt has triggered an interrupt to the interrupt controller. If a bit is clear@@ either no interrupt has been generated@@ or the interrupt is masked. If no port pin@@ other than the one that is being used as an ADC trigger@@ is being used to generate interrupts@@ the appropriate Interrupt Set Enable (ENn) register can disable the interrupts for the port@@ and the ADC interrupt can be used to read back the converted data. Otherwise@@ the port interrupt handler must ignore and clear interrupts on the port pin and wait for the ADC interrupt@@ or the ADC interrupt must be disabled in the EN0 register and the port interrupt handler must poll the ADC registers until the conversion is completed. If no port pin@@ other than the one that is being used as an ADC trigger@@ is being used to generate interrupts@@ the appropriate Interrupt Set Enable (ENn) register can disable the interrupts for the port@@ and the ADC interrupt can be used to read back the converted data. Otherwise@@ the port interrupt handler must ignore and clear interrupts on the port pin and wait for the ADC interrupt@@ or the ADC interrupt must be disabled in the EN0 register and the port interrupt handler must poll the ADC registers until the conversion is completed. Note that if the Port B GPIOADCCTL register is cleared@@ PB4 can still be used as an external trigger for the ADC. This is a legacy mode which allows code written for previous Stellaris devices to operate on this microcontroller. GPIOMIS is the state of the interrupt after masking."]
    pub mis: MIS,
    #[doc = "0x41c - 0x4000 541C 0x4000 641C 0x4000 741C 0x4002 441C GPIO Interrupt Clear (GPIOICR)@@ offset 0x41C The GPIOICR register is the interrupt clear register. Writing a 1 to a bit in this register clears the corresponding interrupt bit in the GPIORIS and GPIOMIS registers. Writing a 0 has no effect."]
    pub icr: ICR,
    #[doc = "0x420 - 0x4000 5420 0x4000 6420 0x4000 7420 0x4002 4420 GPIO Alternate Function Select (GPIOAFSEL)@@ offset 0x420 The GPIOAFSEL register is the mode control select register. If a bit is clear@@ the pin is used as a GPIO and is controlled by the GPIO registers. Setting a bit in this register configures the corresponding GPIO line to be controlled by an associated peripheral. Several possible peripheral functions are multiplexed on each GPIO. The GPIO Port Control (GPIOPCTL) register is used to select one of the possible functions."]
    pub afsel: AFSEL,
    _reserved10: [u8; 220usize],
    #[doc = "0x500 - 0x4000 5500 0x4000 6500 0x4000 7500 0x4002 4500 GPIO 2-mA Drive Select (GPIODR2R)@@ offset 0x500 The GPIODR2R register is the 2-mA drive control register. Each GPIO signal in the port can be individually configured without affecting the other pads. When setting the DRV2 bit for a GPIO signal@@ the corresponding DRV4 bit in the GPIODR4R register and DRV8 bit in the GPIODR8R register are automatically cleared by hardware. By default@@ all GPIO pins have 2-mA drive."]
    pub dr2r: DR2R,
    #[doc = "0x504 - 0x4000 5504 0x4000 6504 0x4000 7504 0x4002 4504 GPIO 4-mA Drive Select (GPIODR4R)@@ offset 0x504 The GPIODR4R register is the 4-mA drive control register. Each GPIO signal in the port can be individually configured without affecting the other pads. When setting the DRV4 bit for a GPIO signal@@ the corresponding DRV2 bit in the GPIODR2R register and DRV8 bit in the GPIODR8R register are automatically cleared by hardware."]
    pub dr4r: DR4R,
    #[doc = "0x508 - 0x4000 5508 0x4000 6508 0x4000 7508 0x4002 4508 GPIO 8-mA Drive Select (GPIODR8R)@@ offset 0x508 The GPIODR8R register is the 8-mA drive control register. Each GPIO signal in the port can be individually configured without affecting the other pads. When setting the DRV8 bit for a GPIO signal@@ the corresponding DRV2 bit in the GPIODR2R register and DRV4 bit in the GPIODR4R register are automatically cleared by hardware. The 8-mA setting is also used for high-current operation. Note: There is no configuration difference between 8-mA and high-current operation. The additional current capacity results from a shift in the VOH/VOL levels."]
    pub dr8r: DR8R,
    #[doc = "0x50c - 0x4000 550C 0x4000 650C 0x4000 750C 0x4002 450C GPIO Open Drain Select (GPIOODR)@@ offset 0x50C The GPIOODR register is the open drain control register. Setting a bit in this register enables the open-drain configuration of the corresponding GPIO pad. When open-drain mode is enabled@@ the corresponding bit should also be set in the GPIO Digital Input Enable (GPIODEN) register . Corresponding bits in the drive strength and slew rate control registers (GPIODR2R@@ GPIODR4R@@ GPIODR8R@@ and GPIOSLR) can be set to achieve the desired rise and fall times. The GPIO acts as an open-drain input if the corresponding bit in the GPIODIR register is cleared. If open drain is selected while the GPIO is configured as an input@@ the GPIO will remain an input and the open-drain selection has no effect until the GPIO is changed to an output. When using the I2C module@@ in addition to configuring the pin to open drain@@ the GPIO Alternate Function Select (GPIOAFSEL) register bits for the I2C clock and data pins should be set"]
    pub odr: ODR,
    #[doc = "0x510 - 0x4000 5510 0x4000 6510 0x4000 7510 0x4002 4510 GPIO Pull-Up Select (GPIOPUR)@@ offset 0x510 The GPIOPUR register is the pull-up control register. When a bit is set@@ a weak pull-up resistor on the corresponding GPIO signal is enabled. Setting a bit in GPIOPUR automatically clears the corresponding bit in the GPIO Pull-Down Select (GPIOPDR) register . Write access to this register is protected with the GPIOCR register. Bits in GPIOCR that are cleared prevent writes to the equivalent bit in this register."]
    pub pur: PUR,
    #[doc = "0x514 - 0x4000 5514 0x4000 6514 0x4000 7514 0x4002 4514 GPIO Pull-Down Select (GPIOPDR)@@ offset 0x514 The GPIOPDR register is the pull-down control register. When a bit is set@@ a weak pull-down resistor on the corresponding GPIO signal is enabled. Setting a bit in GPIOPDR automatically clears the corresponding bit in the GPIO Pull-Up Select (GPIOPUR) register"]
    pub pdr: PDR,
    #[doc = "0x518 - 0x4000 5518 0x4000 6518 0x4000 7518 0x4002 4518 The GPIOSLR register is the slew rate control register. Slew rate control is only available when using the 8-mA drive strength option via the GPIO 8-mA Drive Select (GPIODR8R) register"]
    pub slr: SLR,
    #[doc = "0x51c - 0x4000 551C 0x4000 651C 0x4000 751C 0x4002 451C GPIO Digital Enable (GPIODEN)@@ offset 0x51C Note: Pins configured as digital inputs are Schmitt-triggered. The GPIODEN register is the digital enable register. By default@@ all GPIO signals except those listed below are configured out of reset to be undriven (tristate). Their digital function is disabled; they do not drive a logic value on the pin and they do not allow the pin voltage into the GPIO receiver. To use the pin as a digital input or output (either GPIO or alternate function)@@ the corresponding GPIODEN bit must be set."]
    pub den: DEN,
    #[doc = "0x520 - 0x4000 5520 0x4000 6520 0x4000 7520 0x4002 4520 GPIO Lock (GPIOLOCK)@@ offset 0x520 The GPIOLOCK register enables write access to the GPIOCR register . Writing 0x4C4F.434B to the GPIOLOCK register unlocks the GPIOCR register. Writing any other value to the GPIOLOCK register re-enables the locked state. Reading the GPIOLOCK register returns the lock status rather than the 32-bit value that was previously written. Therefore@@ when write accesses are disabled@@ or locked@@ reading the GPIOLOCK register returns 0x0000.0001. When write accesses are enabled@@ or unlocked@@ reading the GPIOLOCK register returns 0x0000.0000."]
    pub lock: LOCK,
    #[doc = "0x524 - 0x4000 5524 0x4000 6524 0x4000 7524 0x4002 4524 GPIO Commit (GPIOCR)@@ offset 0x524 The GPIOCR register is the commit register. The value of the GPIOCR register determines which bits of the GPIOAFSEL@@ GPIOPUR@@ GPIOPDR@@ and GPIODEN registers are committed when a write to these registers is performed. If a bit in the GPIOCR register is cleared@@ the data being written to the corresponding bit in the GPIOAFSEL@@ GPIOPUR@@ GPIOPDR@@ or GPIODEN registers cannot be committed and retains its previous value. If a bit in the GPIOCR register is set@@ the data being written to the corresponding bit of the GPIOAFSEL@@ GPIOPUR@@ GPIOPDR@@ or GPIODEN registers is committed to the register and reflects the new value. The contents of the GPIOCR register can only be modified if the status in the GPIOLOCK register is unlocked. Writes to the GPIOCR register are ignored if the status in the GPIOLOCK register is locked."]
    pub cr: CR,
    #[doc = "0x528 - 0x4000 5528 0x4000 6528 0x4000 7528 0x4002 4528 The GPIOAMSEL register controls isolation circuits to the analog side of a unified I/O pad. Because the GPIOs may be driven by a 5-V source and affect analog operation@@ analog circuitry requires isolation from the pins when they are not used in their analog function. Each bit of this register controls the isolation circuitry for the corresponding GPIO signal."]
    pub amsel: AMSEL,
    #[doc = "0x52c - This register is not used in cc3xx. equivalant register exsist outside GPIO IP (refer PAD*_config register in the shared comn space) 0x4000 552C 0x4000 652C 0x4000 752C 0x4002 452C GPIO Port Control (GPIOPCTL)@@ offset 0x52C The GPIOPCTL register is used in conjunction with the GPIOAFSEL register and selects the specific peripheral signal for each GPIO pin when using the alternate function mode. Most bits in the GPIOAFSEL register are cleared on reset@@ therefore most GPIO pins are configured as GPIOs by default. When a bit is set in the GPIOAFSEL register@@ the corresponding GPIO signal is controlled by an associated peripheral. The GPIOPCTL register selects one out of a set of peripheral functions for each GPIO@@ providing additional flexibility in signal definition."]
    pub pctl: PCTL,
    #[doc = "0x530 - This register is not used in cc3xx. ADC trigger via GPIO is not supported. 0x4000 5530 0x4000 6530 0x4000 7530 0x4002 4530 GPIO ADC Control (GPIOADCCTL)@@ offset 0x530 This register is used to configure a GPIO pin as a source for the ADC trigger. Note that if the Port B GPIOADCCTL register is cleared@@ PB4 can still be used as an external trigger for the ADC. This is a legacy mode which allows code written for previous Stellaris devices to operate on this microcontroller."]
    pub adcctl: ADCCTL,
    #[doc = "0x534 - 0x4000 5534 0x4000 6534 0x4000 7534 0x4002 4534 GPIO DMA Control (GPIODMACTL)@@ offset 0x534 This register is used to configure a GPIO pin as a source for the ?DMA trigger."]
    pub dmactl: DMACTL,
    #[doc = "0x538 - 0x4000 5538 0x4000 6538 0x4000 7538 0x4002 4538 GPIO Select Interrupt (GPIOSI)@@ offset 0x538 This register is used to enable individual interrupts for each pin. Note: This register is only available on Port P and Port Q."]
    pub si: SI,
    _reserved25: [u8; 2708usize],
    #[doc = "0xfd0 - 0x4000 5FD0 0x4000 6FD0 0x4000 7FD0 0x4002 4FD0 GPIO Peripheral Identification 4 (GPIOPeriphID4)@@ offset 0xFD0 The GPIOPeriphID4@@ GPIOPeriphID5@@ GPIOPeriphID6@@ and GPIOPeriphID7 registers can conceptually be treated as one 32-bit register; each register contains eight bits of the 32-bit register@@ used by software to identify the peripheral."]
    pub periphid4: PERIPHID4,
    #[doc = "0xfd4 - 0x4000 5FD4 0x4000 6FD4 0x4000 7FD4 0x4002 4FD4 GPIO Peripheral Identification 5 (GPIOPeriphID5)@@ offset 0xFD4 The GPIOPeriphID4@@ GPIOPeriphID5@@ GPIOPeriphID6@@ and GPIOPeriphID7 registers can conceptually be treated as one 32-bit register; each register contains eight bits of the 32-bit register@@ used by software to identify the peripheral."]
    pub periphid5: PERIPHID5,
    #[doc = "0xfd8 - 0x4000 5FD8 0x4000 6FD8 0x4000 7FD8 0x4002 4FD8 GPIO Peripheral Identification 6 (GPIOPeriphID6)@@ offset 0xFD8 The GPIOPeriphID4@@ GPIOPeriphID5@@ GPIOPeriphID6@@ and GPIOPeriphID7 registers can conceptually be treated as one 32-bit register; each register contains eight bits of the 32-bit register@@ used by software to identify the peripheral."]
    pub periphid6: PERIPHID6,
    #[doc = "0xfdc - 0x4000 5FDC 0x4000 6FDC 0x4000 7FDC 0x4002 4FDC GPIO Peripheral Identification 7 (GPIOPeriphID7)@@ offset 0xFDC The GPIOPeriphID4@@ GPIOPeriphID5@@ GPIOPeriphID6@@ and GPIOPeriphID7 registers can conceptually be treated as one 32-bit register; each register contains eight bits of the 32-bit register@@ used by software to identify the peripheral."]
    pub periphid7: PERIPHID7,
    #[doc = "0xfe0 - 0x4000 5FE0 0x4000 6FE0 0x4000 7FE0 0x4002 4FE0 GPIO Peripheral Identification 0 (GPIOPeriphID0)@@ offset 0xFE0 The GPIOPeriphID0@@ GPIOPeriphID1@@ GPIOPeriphID2@@ and GPIOPeriphID3 registers can conceptually be treated as one 32-bit register; each register contains eight bits of the 32-bit register@@ used by software to identify the peripheral."]
    pub periphid0: PERIPHID0,
    #[doc = "0xfe4 - 0x4000 5FE4 0x4000 6FE4 0x4000 7FE4 0x4002 4FE4 GPIO Peripheral Identification 1 (GPIOPeriphID1)@@ offset 0xFE4 The GPIOPeriphID0@@ GPIOPeriphID1@@ GPIOPeriphID2@@ and GPIOPeriphID3 registers can conceptually be treated as one 32-bit register; each register contains eight bits of the 32-bit register@@ used by software to identify the peripheral."]
    pub periphid1: PERIPHID1,
    #[doc = "0xfe8 - 0x4000 5FE8 0x4000 6FE8 0x4000 7FE8 0x4002 4FE8 GPIO Peripheral Identification 2 (GPIOPeriphID2)@@ offset 0xFE8 The GPIOPeriphID0@@ GPIOPeriphID1@@ GPIOPeriphID2@@ and GPIOPeriphID3 registers can conceptually be treated as one 32-bit register; each register contains eight bits of the 32-bit register@@ used by software to identify the peripheral."]
    pub periphid2: PERIPHID2,
    #[doc = "0xfec - 0x4000 5FEC 0x4000 6FEC 0x4000 7FEC 0x4002 4FEC GPIO Peripheral Identification 3 (GPIOPeriphID3)@@ offset 0xFEC The GPIOPeriphID0@@ GPIOPeriphID1@@ GPIOPeriphID2@@ and GPIOPeriphID3 registers can conceptually be treated as one 32-bit register; each register contains eight bits of the 32-bit register@@ used by software to identify the peripheral."]
    pub periphid3: PERIPHID3,
    #[doc = "0xff0 - 0x4000 5FF0 0x4000 6FF0 0x4000 7FF0 0x4002 4FF0 GPIO PrimeCell Identification 0 (GPIOPCellID0)@@ offset 0xFF0 The GPIOPCellID0@@ GPIOPCellID1@@ GPIOPCellID2@@ and GPIOPCellID3 registers are four 8-bit wide registers@@ that can conceptually be treated as one 32-bit register. The register is used as a standard cross-peripheral identification system."]
    pub pcellid0: PCELLID0,
    #[doc = "0xff4 - 0x4000 5FF4 0x4000 6FF4 0x4000 7FF4 0x4002 4FF4 GPIO PrimeCell Identification 1 (GPIOPCellID1)@@ offset 0xFF4 The GPIOPCellID0@@ GPIOPCellID1@@ GPIOPCellID2@@ and GPIOPCellID3 registers are four 8-bit wide registers@@ that can conceptually be treated as one 32-bit register. The register is used as a standard cross-peripheral identification system."]
    pub pcellid1: PCELLID1,
    #[doc = "0xff8 - 0x4000 5FF8 0x4000 6FF8 0x4000 7FF8 0x4002 4FF8 GPIO PrimeCell Identification 2 (GPIOPCellID2)@@ offset 0xFF8 The GPIOPCellID0@@ GPIOPCellID1@@ GPIOPCellID2@@ and GPIOPCellID3 registers are four 8-bit wide registers@@ that can conceptually be treated as one 32-bit register. The register is used as a standard cross-peripheral identification system."]
    pub pcellid2: PCELLID2,
    #[doc = "0xffc - 0x4000 5FFC 0x4000 6FFC 0x4000 7FFC 0x4002 4FFC GPIO PrimeCell Identification 3 (GPIOPCellID3)@@ offset 0xFFC The GPIOPCellID0@@ GPIOPCellID1@@ GPIOPCellID2@@ and GPIOPCellID3 registers are four 8-bit wide registers@@ that can conceptually be treated as one 32-bit register. The register is used as a standard cross-peripheral identification system.0xb1 ****************************************************************************"]
    pub pcellid3: PCELLID3,
}
#[doc = "0x4000 5000 0x4000 6000 0x4000 7000 0x4002 4000 GPIO Data (GPIODATA)@@ offset 0x000 The GPIODATA register is the data register. In software control mode@@ values written in the GPIODATA register are transferred onto the GPIO port pins if the respective pins have been configured as outputs through the GPIO Direction (GPIODIR) register (see page 653). In order to write to GPIODATA@@ the corresponding bits in the mask@@ resulting from the address bus bits \\[9:2\\]@@ must be set. Otherwise@@ the bit values remain unchanged by the write. Similarly@@ the values read from this register are determined for each bit by the mask bit derived from the address used to access the data register@@ bits \\[9:2\\]. Bits that are set in the address mask cause the corresponding bits in GPIODATA to be read@@ and bits that are clear in the address mask cause the corresponding bits in GPIODATA to be read as 0@@ regardless of their value. A read from GPIODATA returns the last bit value written if the respective pins are configured as outputs@@ or it returns the value on the corresponding input pin when these are configured as inputs. All bits are cleared by a reset.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [data](data) module"]
pub type DATA = crate::Reg<u32, _DATA>;
#[allow(missing_docs)]
#[doc(hidden)]
pub struct _DATA;
#[doc = "`read()` method returns [data::R](data::R) reader structure"]
impl crate::Readable for DATA {}
#[doc = "`write(|w| ..)` method takes [data::W](data::W) writer structure"]
impl crate::Writable for DATA {}
#[doc = "0x4000 5000 0x4000 6000 0x4000 7000 0x4002 4000 GPIO Data (GPIODATA)@@ offset 0x000 The GPIODATA register is the data register. In software control mode@@ values written in the GPIODATA register are transferred onto the GPIO port pins if the respective pins have been configured as outputs through the GPIO Direction (GPIODIR) register (see page 653). In order to write to GPIODATA@@ the corresponding bits in the mask@@ resulting from the address bus bits \\[9:2\\]@@ must be set. Otherwise@@ the bit values remain unchanged by the write. Similarly@@ the values read from this register are determined for each bit by the mask bit derived from the address used to access the data register@@ bits \\[9:2\\]. Bits that are set in the address mask cause the corresponding bits in GPIODATA to be read@@ and bits that are clear in the address mask cause the corresponding bits in GPIODATA to be read as 0@@ regardless of their value. A read from GPIODATA returns the last bit value written if the respective pins are configured as outputs@@ or it returns the value on the corresponding input pin when these are configured as inputs. All bits are cleared by a reset."]
pub mod data;
#[doc = "0x4000 5400 0x4000 6400 0x4000 7400 0x4002 4400 GPIO Direction (GPIODIR)@@ offset 0x400 The GPIODIR register is the data direction register. Setting a bit in the GPIODIR register configures the corresponding pin to be an output@@ while clearing a bit configures the corresponding pin to be an input. All bits are cleared by a reset@@ meaning all GPIO pins are inputs by default.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dir](dir) module"]
pub type DIR = crate::Reg<u32, _DIR>;
#[allow(missing_docs)]
#[doc(hidden)]
pub struct _DIR;
#[doc = "`read()` method returns [dir::R](dir::R) reader structure"]
impl crate::Readable for DIR {}
#[doc = "`write(|w| ..)` method takes [dir::W](dir::W) writer structure"]
impl crate::Writable for DIR {}
#[doc = "0x4000 5400 0x4000 6400 0x4000 7400 0x4002 4400 GPIO Direction (GPIODIR)@@ offset 0x400 The GPIODIR register is the data direction register. Setting a bit in the GPIODIR register configures the corresponding pin to be an output@@ while clearing a bit configures the corresponding pin to be an input. All bits are cleared by a reset@@ meaning all GPIO pins are inputs by default."]
pub mod dir;
#[doc = "0x4000 5404 0x4000 6404 0x4000 7404 0x4002 4404 GPIO Interrupt Sense (GPIOIS)@@ offset 0x404 The GPIOIS register is the interrupt sense register. Setting a bit in the GPIOIS register configures the corresponding pin to detect levels@@ while clearing a bit configures the corresponding pin to detect edges. All bits are cleared by a reset.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [is](is) module"]
pub type IS = crate::Reg<u32, _IS>;
#[allow(missing_docs)]
#[doc(hidden)]
pub struct _IS;
#[doc = "`read()` method returns [is::R](is::R) reader structure"]
impl crate::Readable for IS {}
#[doc = "`write(|w| ..)` method takes [is::W](is::W) writer structure"]
impl crate::Writable for IS {}
#[doc = "0x4000 5404 0x4000 6404 0x4000 7404 0x4002 4404 GPIO Interrupt Sense (GPIOIS)@@ offset 0x404 The GPIOIS register is the interrupt sense register. Setting a bit in the GPIOIS register configures the corresponding pin to detect levels@@ while clearing a bit configures the corresponding pin to detect edges. All bits are cleared by a reset."]
pub mod is;
#[doc = "0x4000 5408 0x4000 6408 0x4000 7408 0x4002 4408 GPIO Interrupt Both Edges (GPIOIBE)@@ offset 0x408 The GPIOIBE register allows both edges to cause interrupts. When the corresponding bit in the GPIO Interrupt Sense (GPIOIS) register is set to detect edges@@ setting a bit in the GPIOIBE register configures the corresponding pin to detect both rising and falling edges@@ regardless of the corresponding bit in the GPIO Interrupt Event (GPIOIEV) register . Clearing a bit configures the pin to be controlled by the GPIOIEV register. All bits are cleared by a reset.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ibe](ibe) module"]
pub type IBE = crate::Reg<u32, _IBE>;
#[allow(missing_docs)]
#[doc(hidden)]
pub struct _IBE;
#[doc = "`read()` method returns [ibe::R](ibe::R) reader structure"]
impl crate::Readable for IBE {}
#[doc = "`write(|w| ..)` method takes [ibe::W](ibe::W) writer structure"]
impl crate::Writable for IBE {}
#[doc = "0x4000 5408 0x4000 6408 0x4000 7408 0x4002 4408 GPIO Interrupt Both Edges (GPIOIBE)@@ offset 0x408 The GPIOIBE register allows both edges to cause interrupts. When the corresponding bit in the GPIO Interrupt Sense (GPIOIS) register is set to detect edges@@ setting a bit in the GPIOIBE register configures the corresponding pin to detect both rising and falling edges@@ regardless of the corresponding bit in the GPIO Interrupt Event (GPIOIEV) register . Clearing a bit configures the pin to be controlled by the GPIOIEV register. All bits are cleared by a reset."]
pub mod ibe;
#[doc = "0x4000 540C 0x4000 640C 0x4000 740C 0x4002 440C GPIO Interrupt Event (GPIOIEV)@@ offset 0x40C The GPIOIEV register is the interrupt event register. Setting a bit in the GPIOIEV register configures the corresponding pin to detect rising edges or high levels@@ depending on the corresponding bit value in the GPIO Interrupt Sense (GPIOIS) register . Clearing a bit configures the pin to detect falling edges or low levels@@ depending on the corresponding bit value in the GPIOIS register. All bits are cleared by a reset.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [iev](iev) module"]
pub type IEV = crate::Reg<u32, _IEV>;
#[allow(missing_docs)]
#[doc(hidden)]
pub struct _IEV;
#[doc = "`read()` method returns [iev::R](iev::R) reader structure"]
impl crate::Readable for IEV {}
#[doc = "`write(|w| ..)` method takes [iev::W](iev::W) writer structure"]
impl crate::Writable for IEV {}
#[doc = "0x4000 540C 0x4000 640C 0x4000 740C 0x4002 440C GPIO Interrupt Event (GPIOIEV)@@ offset 0x40C The GPIOIEV register is the interrupt event register. Setting a bit in the GPIOIEV register configures the corresponding pin to detect rising edges or high levels@@ depending on the corresponding bit value in the GPIO Interrupt Sense (GPIOIS) register . Clearing a bit configures the pin to detect falling edges or low levels@@ depending on the corresponding bit value in the GPIOIS register. All bits are cleared by a reset."]
pub mod iev;
#[doc = "0x4000 5410 0x4000 6410 0x4000 7410 0x4002 4410 GPIO Interrupt Mask (GPIOIM)@@ offset 0x410 The GPIOIM register is the interrupt mask register. Setting a bit in the GPIOIM register allows interrupts that are generated by the corresponding pin to be sent to the interrupt controller on the combined interrupt signal. Clearing a bit prevents an interrupt on the corresponding pin from being sent to the interrupt controller. All bits are cleared by a reset.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [im](im) module"]
pub type IM = crate::Reg<u32, _IM>;
#[allow(missing_docs)]
#[doc(hidden)]
pub struct _IM;
#[doc = "`read()` method returns [im::R](im::R) reader structure"]
impl crate::Readable for IM {}
#[doc = "`write(|w| ..)` method takes [im::W](im::W) writer structure"]
impl crate::Writable for IM {}
#[doc = "0x4000 5410 0x4000 6410 0x4000 7410 0x4002 4410 GPIO Interrupt Mask (GPIOIM)@@ offset 0x410 The GPIOIM register is the interrupt mask register. Setting a bit in the GPIOIM register allows interrupts that are generated by the corresponding pin to be sent to the interrupt controller on the combined interrupt signal. Clearing a bit prevents an interrupt on the corresponding pin from being sent to the interrupt controller. All bits are cleared by a reset."]
pub mod im;
#[doc = "0x4000 5414 0x4000 6414 0x4000 7414 0x4002 4414 GPIO Raw Interrupt Status (GPIORIS)@@ offset 0x414 The GPIORIS register is the raw interrupt status register. A bit in this register is set when an interrupt condition occurs on the corresponding GPIO pin. If the corresponding bit in the GPIO Interrupt Mask (GPIOIM) register is set@@ the interrupt is sent to the interrupt controller. Bits read as zero indicate that corresponding input pins have not initiated an interrupt. A bit in this register can be cleared by writing a 1 to the corresponding bit in the GPIO Interrupt Clear (GPIOICR) register.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ris](ris) module"]
pub type RIS = crate::Reg<u32, _RIS>;
#[allow(missing_docs)]
#[doc(hidden)]
pub struct _RIS;
#[doc = "`read()` method returns [ris::R](ris::R) reader structure"]
impl crate::Readable for RIS {}
#[doc = "`write(|w| ..)` method takes [ris::W](ris::W) writer structure"]
impl crate::Writable for RIS {}
#[doc = "0x4000 5414 0x4000 6414 0x4000 7414 0x4002 4414 GPIO Raw Interrupt Status (GPIORIS)@@ offset 0x414 The GPIORIS register is the raw interrupt status register. A bit in this register is set when an interrupt condition occurs on the corresponding GPIO pin. If the corresponding bit in the GPIO Interrupt Mask (GPIOIM) register is set@@ the interrupt is sent to the interrupt controller. Bits read as zero indicate that corresponding input pins have not initiated an interrupt. A bit in this register can be cleared by writing a 1 to the corresponding bit in the GPIO Interrupt Clear (GPIOICR) register."]
pub mod ris;
#[doc = "0x4000 5418 0x4000 6418 0x4000 7418 0x4002 4418 GPIO Masked Interrupt Status (GPIOMIS)@@ offset 0x418 The GPIOMIS register is the masked interrupt status register. If a bit is set in this register@@ the corresponding interrupt has triggered an interrupt to the interrupt controller. If a bit is clear@@ either no interrupt has been generated@@ or the interrupt is masked. If no port pin@@ other than the one that is being used as an ADC trigger@@ is being used to generate interrupts@@ the appropriate Interrupt Set Enable (ENn) register can disable the interrupts for the port@@ and the ADC interrupt can be used to read back the converted data. Otherwise@@ the port interrupt handler must ignore and clear interrupts on the port pin and wait for the ADC interrupt@@ or the ADC interrupt must be disabled in the EN0 register and the port interrupt handler must poll the ADC registers until the conversion is completed. If no port pin@@ other than the one that is being used as an ADC trigger@@ is being used to generate interrupts@@ the appropriate Interrupt Set Enable (ENn) register can disable the interrupts for the port@@ and the ADC interrupt can be used to read back the converted data. Otherwise@@ the port interrupt handler must ignore and clear interrupts on the port pin and wait for the ADC interrupt@@ or the ADC interrupt must be disabled in the EN0 register and the port interrupt handler must poll the ADC registers until the conversion is completed. Note that if the Port B GPIOADCCTL register is cleared@@ PB4 can still be used as an external trigger for the ADC. This is a legacy mode which allows code written for previous Stellaris devices to operate on this microcontroller. GPIOMIS is the state of the interrupt after masking.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mis](mis) module"]
pub type MIS = crate::Reg<u32, _MIS>;
#[allow(missing_docs)]
#[doc(hidden)]
pub struct _MIS;
#[doc = "`read()` method returns [mis::R](mis::R) reader structure"]
impl crate::Readable for MIS {}
#[doc = "`write(|w| ..)` method takes [mis::W](mis::W) writer structure"]
impl crate::Writable for MIS {}
#[doc = "0x4000 5418 0x4000 6418 0x4000 7418 0x4002 4418 GPIO Masked Interrupt Status (GPIOMIS)@@ offset 0x418 The GPIOMIS register is the masked interrupt status register. If a bit is set in this register@@ the corresponding interrupt has triggered an interrupt to the interrupt controller. If a bit is clear@@ either no interrupt has been generated@@ or the interrupt is masked. If no port pin@@ other than the one that is being used as an ADC trigger@@ is being used to generate interrupts@@ the appropriate Interrupt Set Enable (ENn) register can disable the interrupts for the port@@ and the ADC interrupt can be used to read back the converted data. Otherwise@@ the port interrupt handler must ignore and clear interrupts on the port pin and wait for the ADC interrupt@@ or the ADC interrupt must be disabled in the EN0 register and the port interrupt handler must poll the ADC registers until the conversion is completed. If no port pin@@ other than the one that is being used as an ADC trigger@@ is being used to generate interrupts@@ the appropriate Interrupt Set Enable (ENn) register can disable the interrupts for the port@@ and the ADC interrupt can be used to read back the converted data. Otherwise@@ the port interrupt handler must ignore and clear interrupts on the port pin and wait for the ADC interrupt@@ or the ADC interrupt must be disabled in the EN0 register and the port interrupt handler must poll the ADC registers until the conversion is completed. Note that if the Port B GPIOADCCTL register is cleared@@ PB4 can still be used as an external trigger for the ADC. This is a legacy mode which allows code written for previous Stellaris devices to operate on this microcontroller. GPIOMIS is the state of the interrupt after masking."]
pub mod mis;
#[doc = "0x4000 541C 0x4000 641C 0x4000 741C 0x4002 441C GPIO Interrupt Clear (GPIOICR)@@ offset 0x41C The GPIOICR register is the interrupt clear register. Writing a 1 to a bit in this register clears the corresponding interrupt bit in the GPIORIS and GPIOMIS registers. Writing a 0 has no effect.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [icr](icr) module"]
pub type ICR = crate::Reg<u32, _ICR>;
#[allow(missing_docs)]
#[doc(hidden)]
pub struct _ICR;
#[doc = "`read()` method returns [icr::R](icr::R) reader structure"]
impl crate::Readable for ICR {}
#[doc = "`write(|w| ..)` method takes [icr::W](icr::W) writer structure"]
impl crate::Writable for ICR {}
#[doc = "0x4000 541C 0x4000 641C 0x4000 741C 0x4002 441C GPIO Interrupt Clear (GPIOICR)@@ offset 0x41C The GPIOICR register is the interrupt clear register. Writing a 1 to a bit in this register clears the corresponding interrupt bit in the GPIORIS and GPIOMIS registers. Writing a 0 has no effect."]
pub mod icr;
#[doc = "0x4000 5420 0x4000 6420 0x4000 7420 0x4002 4420 GPIO Alternate Function Select (GPIOAFSEL)@@ offset 0x420 The GPIOAFSEL register is the mode control select register. If a bit is clear@@ the pin is used as a GPIO and is controlled by the GPIO registers. Setting a bit in this register configures the corresponding GPIO line to be controlled by an associated peripheral. Several possible peripheral functions are multiplexed on each GPIO. The GPIO Port Control (GPIOPCTL) register is used to select one of the possible functions.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [afsel](afsel) module"]
pub type AFSEL = crate::Reg<u32, _AFSEL>;
#[allow(missing_docs)]
#[doc(hidden)]
pub struct _AFSEL;
#[doc = "`read()` method returns [afsel::R](afsel::R) reader structure"]
impl crate::Readable for AFSEL {}
#[doc = "`write(|w| ..)` method takes [afsel::W](afsel::W) writer structure"]
impl crate::Writable for AFSEL {}
#[doc = "0x4000 5420 0x4000 6420 0x4000 7420 0x4002 4420 GPIO Alternate Function Select (GPIOAFSEL)@@ offset 0x420 The GPIOAFSEL register is the mode control select register. If a bit is clear@@ the pin is used as a GPIO and is controlled by the GPIO registers. Setting a bit in this register configures the corresponding GPIO line to be controlled by an associated peripheral. Several possible peripheral functions are multiplexed on each GPIO. The GPIO Port Control (GPIOPCTL) register is used to select one of the possible functions."]
pub mod afsel;
#[doc = "0x4000 5500 0x4000 6500 0x4000 7500 0x4002 4500 GPIO 2-mA Drive Select (GPIODR2R)@@ offset 0x500 The GPIODR2R register is the 2-mA drive control register. Each GPIO signal in the port can be individually configured without affecting the other pads. When setting the DRV2 bit for a GPIO signal@@ the corresponding DRV4 bit in the GPIODR4R register and DRV8 bit in the GPIODR8R register are automatically cleared by hardware. By default@@ all GPIO pins have 2-mA drive.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dr2r](dr2r) module"]
pub type DR2R = crate::Reg<u32, _DR2R>;
#[allow(missing_docs)]
#[doc(hidden)]
pub struct _DR2R;
#[doc = "`read()` method returns [dr2r::R](dr2r::R) reader structure"]
impl crate::Readable for DR2R {}
#[doc = "`write(|w| ..)` method takes [dr2r::W](dr2r::W) writer structure"]
impl crate::Writable for DR2R {}
#[doc = "0x4000 5500 0x4000 6500 0x4000 7500 0x4002 4500 GPIO 2-mA Drive Select (GPIODR2R)@@ offset 0x500 The GPIODR2R register is the 2-mA drive control register. Each GPIO signal in the port can be individually configured without affecting the other pads. When setting the DRV2 bit for a GPIO signal@@ the corresponding DRV4 bit in the GPIODR4R register and DRV8 bit in the GPIODR8R register are automatically cleared by hardware. By default@@ all GPIO pins have 2-mA drive."]
pub mod dr2r;
#[doc = "0x4000 5504 0x4000 6504 0x4000 7504 0x4002 4504 GPIO 4-mA Drive Select (GPIODR4R)@@ offset 0x504 The GPIODR4R register is the 4-mA drive control register. Each GPIO signal in the port can be individually configured without affecting the other pads. When setting the DRV4 bit for a GPIO signal@@ the corresponding DRV2 bit in the GPIODR2R register and DRV8 bit in the GPIODR8R register are automatically cleared by hardware.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dr4r](dr4r) module"]
pub type DR4R = crate::Reg<u32, _DR4R>;
#[allow(missing_docs)]
#[doc(hidden)]
pub struct _DR4R;
#[doc = "`read()` method returns [dr4r::R](dr4r::R) reader structure"]
impl crate::Readable for DR4R {}
#[doc = "`write(|w| ..)` method takes [dr4r::W](dr4r::W) writer structure"]
impl crate::Writable for DR4R {}
#[doc = "0x4000 5504 0x4000 6504 0x4000 7504 0x4002 4504 GPIO 4-mA Drive Select (GPIODR4R)@@ offset 0x504 The GPIODR4R register is the 4-mA drive control register. Each GPIO signal in the port can be individually configured without affecting the other pads. When setting the DRV4 bit for a GPIO signal@@ the corresponding DRV2 bit in the GPIODR2R register and DRV8 bit in the GPIODR8R register are automatically cleared by hardware."]
pub mod dr4r;
#[doc = "0x4000 5508 0x4000 6508 0x4000 7508 0x4002 4508 GPIO 8-mA Drive Select (GPIODR8R)@@ offset 0x508 The GPIODR8R register is the 8-mA drive control register. Each GPIO signal in the port can be individually configured without affecting the other pads. When setting the DRV8 bit for a GPIO signal@@ the corresponding DRV2 bit in the GPIODR2R register and DRV4 bit in the GPIODR4R register are automatically cleared by hardware. The 8-mA setting is also used for high-current operation. Note: There is no configuration difference between 8-mA and high-current operation. The additional current capacity results from a shift in the VOH/VOL levels.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dr8r](dr8r) module"]
pub type DR8R = crate::Reg<u32, _DR8R>;
#[allow(missing_docs)]
#[doc(hidden)]
pub struct _DR8R;
#[doc = "`read()` method returns [dr8r::R](dr8r::R) reader structure"]
impl crate::Readable for DR8R {}
#[doc = "`write(|w| ..)` method takes [dr8r::W](dr8r::W) writer structure"]
impl crate::Writable for DR8R {}
#[doc = "0x4000 5508 0x4000 6508 0x4000 7508 0x4002 4508 GPIO 8-mA Drive Select (GPIODR8R)@@ offset 0x508 The GPIODR8R register is the 8-mA drive control register. Each GPIO signal in the port can be individually configured without affecting the other pads. When setting the DRV8 bit for a GPIO signal@@ the corresponding DRV2 bit in the GPIODR2R register and DRV4 bit in the GPIODR4R register are automatically cleared by hardware. The 8-mA setting is also used for high-current operation. Note: There is no configuration difference between 8-mA and high-current operation. The additional current capacity results from a shift in the VOH/VOL levels."]
pub mod dr8r;
#[doc = "0x4000 550C 0x4000 650C 0x4000 750C 0x4002 450C GPIO Open Drain Select (GPIOODR)@@ offset 0x50C The GPIOODR register is the open drain control register. Setting a bit in this register enables the open-drain configuration of the corresponding GPIO pad. When open-drain mode is enabled@@ the corresponding bit should also be set in the GPIO Digital Input Enable (GPIODEN) register . Corresponding bits in the drive strength and slew rate control registers (GPIODR2R@@ GPIODR4R@@ GPIODR8R@@ and GPIOSLR) can be set to achieve the desired rise and fall times. The GPIO acts as an open-drain input if the corresponding bit in the GPIODIR register is cleared. If open drain is selected while the GPIO is configured as an input@@ the GPIO will remain an input and the open-drain selection has no effect until the GPIO is changed to an output. When using the I2C module@@ in addition to configuring the pin to open drain@@ the GPIO Alternate Function Select (GPIOAFSEL) register bits for the I2C clock and data pins should be set\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [odr](odr) module"]
pub type ODR = crate::Reg<u32, _ODR>;
#[allow(missing_docs)]
#[doc(hidden)]
pub struct _ODR;
#[doc = "`read()` method returns [odr::R](odr::R) reader structure"]
impl crate::Readable for ODR {}
#[doc = "`write(|w| ..)` method takes [odr::W](odr::W) writer structure"]
impl crate::Writable for ODR {}
#[doc = "0x4000 550C 0x4000 650C 0x4000 750C 0x4002 450C GPIO Open Drain Select (GPIOODR)@@ offset 0x50C The GPIOODR register is the open drain control register. Setting a bit in this register enables the open-drain configuration of the corresponding GPIO pad. When open-drain mode is enabled@@ the corresponding bit should also be set in the GPIO Digital Input Enable (GPIODEN) register . Corresponding bits in the drive strength and slew rate control registers (GPIODR2R@@ GPIODR4R@@ GPIODR8R@@ and GPIOSLR) can be set to achieve the desired rise and fall times. The GPIO acts as an open-drain input if the corresponding bit in the GPIODIR register is cleared. If open drain is selected while the GPIO is configured as an input@@ the GPIO will remain an input and the open-drain selection has no effect until the GPIO is changed to an output. When using the I2C module@@ in addition to configuring the pin to open drain@@ the GPIO Alternate Function Select (GPIOAFSEL) register bits for the I2C clock and data pins should be set"]
pub mod odr;
#[doc = "0x4000 5510 0x4000 6510 0x4000 7510 0x4002 4510 GPIO Pull-Up Select (GPIOPUR)@@ offset 0x510 The GPIOPUR register is the pull-up control register. When a bit is set@@ a weak pull-up resistor on the corresponding GPIO signal is enabled. Setting a bit in GPIOPUR automatically clears the corresponding bit in the GPIO Pull-Down Select (GPIOPDR) register . Write access to this register is protected with the GPIOCR register. Bits in GPIOCR that are cleared prevent writes to the equivalent bit in this register.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pur](pur) module"]
pub type PUR = crate::Reg<u32, _PUR>;
#[allow(missing_docs)]
#[doc(hidden)]
pub struct _PUR;
#[doc = "`read()` method returns [pur::R](pur::R) reader structure"]
impl crate::Readable for PUR {}
#[doc = "`write(|w| ..)` method takes [pur::W](pur::W) writer structure"]
impl crate::Writable for PUR {}
#[doc = "0x4000 5510 0x4000 6510 0x4000 7510 0x4002 4510 GPIO Pull-Up Select (GPIOPUR)@@ offset 0x510 The GPIOPUR register is the pull-up control register. When a bit is set@@ a weak pull-up resistor on the corresponding GPIO signal is enabled. Setting a bit in GPIOPUR automatically clears the corresponding bit in the GPIO Pull-Down Select (GPIOPDR) register . Write access to this register is protected with the GPIOCR register. Bits in GPIOCR that are cleared prevent writes to the equivalent bit in this register."]
pub mod pur;
#[doc = "0x4000 5514 0x4000 6514 0x4000 7514 0x4002 4514 GPIO Pull-Down Select (GPIOPDR)@@ offset 0x514 The GPIOPDR register is the pull-down control register. When a bit is set@@ a weak pull-down resistor on the corresponding GPIO signal is enabled. Setting a bit in GPIOPDR automatically clears the corresponding bit in the GPIO Pull-Up Select (GPIOPUR) register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pdr](pdr) module"]
pub type PDR = crate::Reg<u32, _PDR>;
#[allow(missing_docs)]
#[doc(hidden)]
pub struct _PDR;
#[doc = "`read()` method returns [pdr::R](pdr::R) reader structure"]
impl crate::Readable for PDR {}
#[doc = "`write(|w| ..)` method takes [pdr::W](pdr::W) writer structure"]
impl crate::Writable for PDR {}
#[doc = "0x4000 5514 0x4000 6514 0x4000 7514 0x4002 4514 GPIO Pull-Down Select (GPIOPDR)@@ offset 0x514 The GPIOPDR register is the pull-down control register. When a bit is set@@ a weak pull-down resistor on the corresponding GPIO signal is enabled. Setting a bit in GPIOPDR automatically clears the corresponding bit in the GPIO Pull-Up Select (GPIOPUR) register"]
pub mod pdr;
#[doc = "0x4000 5518 0x4000 6518 0x4000 7518 0x4002 4518 The GPIOSLR register is the slew rate control register. Slew rate control is only available when using the 8-mA drive strength option via the GPIO 8-mA Drive Select (GPIODR8R) register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [slr](slr) module"]
pub type SLR = crate::Reg<u32, _SLR>;
#[allow(missing_docs)]
#[doc(hidden)]
pub struct _SLR;
#[doc = "`read()` method returns [slr::R](slr::R) reader structure"]
impl crate::Readable for SLR {}
#[doc = "`write(|w| ..)` method takes [slr::W](slr::W) writer structure"]
impl crate::Writable for SLR {}
#[doc = "0x4000 5518 0x4000 6518 0x4000 7518 0x4002 4518 The GPIOSLR register is the slew rate control register. Slew rate control is only available when using the 8-mA drive strength option via the GPIO 8-mA Drive Select (GPIODR8R) register"]
pub mod slr;
#[doc = "0x4000 551C 0x4000 651C 0x4000 751C 0x4002 451C GPIO Digital Enable (GPIODEN)@@ offset 0x51C Note: Pins configured as digital inputs are Schmitt-triggered. The GPIODEN register is the digital enable register. By default@@ all GPIO signals except those listed below are configured out of reset to be undriven (tristate). Their digital function is disabled; they do not drive a logic value on the pin and they do not allow the pin voltage into the GPIO receiver. To use the pin as a digital input or output (either GPIO or alternate function)@@ the corresponding GPIODEN bit must be set.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [den](den) module"]
pub type DEN = crate::Reg<u32, _DEN>;
#[allow(missing_docs)]
#[doc(hidden)]
pub struct _DEN;
#[doc = "`read()` method returns [den::R](den::R) reader structure"]
impl crate::Readable for DEN {}
#[doc = "`write(|w| ..)` method takes [den::W](den::W) writer structure"]
impl crate::Writable for DEN {}
#[doc = "0x4000 551C 0x4000 651C 0x4000 751C 0x4002 451C GPIO Digital Enable (GPIODEN)@@ offset 0x51C Note: Pins configured as digital inputs are Schmitt-triggered. The GPIODEN register is the digital enable register. By default@@ all GPIO signals except those listed below are configured out of reset to be undriven (tristate). Their digital function is disabled; they do not drive a logic value on the pin and they do not allow the pin voltage into the GPIO receiver. To use the pin as a digital input or output (either GPIO or alternate function)@@ the corresponding GPIODEN bit must be set."]
pub mod den;
#[doc = "0x4000 5520 0x4000 6520 0x4000 7520 0x4002 4520 GPIO Lock (GPIOLOCK)@@ offset 0x520 The GPIOLOCK register enables write access to the GPIOCR register . Writing 0x4C4F.434B to the GPIOLOCK register unlocks the GPIOCR register. Writing any other value to the GPIOLOCK register re-enables the locked state. Reading the GPIOLOCK register returns the lock status rather than the 32-bit value that was previously written. Therefore@@ when write accesses are disabled@@ or locked@@ reading the GPIOLOCK register returns 0x0000.0001. When write accesses are enabled@@ or unlocked@@ reading the GPIOLOCK register returns 0x0000.0000.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [lock](lock) module"]
pub type LOCK = crate::Reg<u32, _LOCK>;
#[allow(missing_docs)]
#[doc(hidden)]
pub struct _LOCK;
#[doc = "`read()` method returns [lock::R](lock::R) reader structure"]
impl crate::Readable for LOCK {}
#[doc = "`write(|w| ..)` method takes [lock::W](lock::W) writer structure"]
impl crate::Writable for LOCK {}
#[doc = "0x4000 5520 0x4000 6520 0x4000 7520 0x4002 4520 GPIO Lock (GPIOLOCK)@@ offset 0x520 The GPIOLOCK register enables write access to the GPIOCR register . Writing 0x4C4F.434B to the GPIOLOCK register unlocks the GPIOCR register. Writing any other value to the GPIOLOCK register re-enables the locked state. Reading the GPIOLOCK register returns the lock status rather than the 32-bit value that was previously written. Therefore@@ when write accesses are disabled@@ or locked@@ reading the GPIOLOCK register returns 0x0000.0001. When write accesses are enabled@@ or unlocked@@ reading the GPIOLOCK register returns 0x0000.0000."]
pub mod lock;
#[doc = "0x4000 5524 0x4000 6524 0x4000 7524 0x4002 4524 GPIO Commit (GPIOCR)@@ offset 0x524 The GPIOCR register is the commit register. The value of the GPIOCR register determines which bits of the GPIOAFSEL@@ GPIOPUR@@ GPIOPDR@@ and GPIODEN registers are committed when a write to these registers is performed. If a bit in the GPIOCR register is cleared@@ the data being written to the corresponding bit in the GPIOAFSEL@@ GPIOPUR@@ GPIOPDR@@ or GPIODEN registers cannot be committed and retains its previous value. If a bit in the GPIOCR register is set@@ the data being written to the corresponding bit of the GPIOAFSEL@@ GPIOPUR@@ GPIOPDR@@ or GPIODEN registers is committed to the register and reflects the new value. The contents of the GPIOCR register can only be modified if the status in the GPIOLOCK register is unlocked. Writes to the GPIOCR register are ignored if the status in the GPIOLOCK register is locked.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cr](cr) module"]
pub type CR = crate::Reg<u32, _CR>;
#[allow(missing_docs)]
#[doc(hidden)]
pub struct _CR;
#[doc = "`read()` method returns [cr::R](cr::R) reader structure"]
impl crate::Readable for CR {}
#[doc = "`write(|w| ..)` method takes [cr::W](cr::W) writer structure"]
impl crate::Writable for CR {}
#[doc = "0x4000 5524 0x4000 6524 0x4000 7524 0x4002 4524 GPIO Commit (GPIOCR)@@ offset 0x524 The GPIOCR register is the commit register. The value of the GPIOCR register determines which bits of the GPIOAFSEL@@ GPIOPUR@@ GPIOPDR@@ and GPIODEN registers are committed when a write to these registers is performed. If a bit in the GPIOCR register is cleared@@ the data being written to the corresponding bit in the GPIOAFSEL@@ GPIOPUR@@ GPIOPDR@@ or GPIODEN registers cannot be committed and retains its previous value. If a bit in the GPIOCR register is set@@ the data being written to the corresponding bit of the GPIOAFSEL@@ GPIOPUR@@ GPIOPDR@@ or GPIODEN registers is committed to the register and reflects the new value. The contents of the GPIOCR register can only be modified if the status in the GPIOLOCK register is unlocked. Writes to the GPIOCR register are ignored if the status in the GPIOLOCK register is locked."]
pub mod cr;
#[doc = "0x4000 5528 0x4000 6528 0x4000 7528 0x4002 4528 The GPIOAMSEL register controls isolation circuits to the analog side of a unified I/O pad. Because the GPIOs may be driven by a 5-V source and affect analog operation@@ analog circuitry requires isolation from the pins when they are not used in their analog function. Each bit of this register controls the isolation circuitry for the corresponding GPIO signal.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [amsel](amsel) module"]
pub type AMSEL = crate::Reg<u32, _AMSEL>;
#[allow(missing_docs)]
#[doc(hidden)]
pub struct _AMSEL;
#[doc = "`read()` method returns [amsel::R](amsel::R) reader structure"]
impl crate::Readable for AMSEL {}
#[doc = "`write(|w| ..)` method takes [amsel::W](amsel::W) writer structure"]
impl crate::Writable for AMSEL {}
#[doc = "0x4000 5528 0x4000 6528 0x4000 7528 0x4002 4528 The GPIOAMSEL register controls isolation circuits to the analog side of a unified I/O pad. Because the GPIOs may be driven by a 5-V source and affect analog operation@@ analog circuitry requires isolation from the pins when they are not used in their analog function. Each bit of this register controls the isolation circuitry for the corresponding GPIO signal."]
pub mod amsel;
#[doc = "This register is not used in cc3xx. equivalant register exsist outside GPIO IP (refer PAD*_config register in the shared comn space) 0x4000 552C 0x4000 652C 0x4000 752C 0x4002 452C GPIO Port Control (GPIOPCTL)@@ offset 0x52C The GPIOPCTL register is used in conjunction with the GPIOAFSEL register and selects the specific peripheral signal for each GPIO pin when using the alternate function mode. Most bits in the GPIOAFSEL register are cleared on reset@@ therefore most GPIO pins are configured as GPIOs by default. When a bit is set in the GPIOAFSEL register@@ the corresponding GPIO signal is controlled by an associated peripheral. The GPIOPCTL register selects one out of a set of peripheral functions for each GPIO@@ providing additional flexibility in signal definition.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pctl](pctl) module"]
pub type PCTL = crate::Reg<u32, _PCTL>;
#[allow(missing_docs)]
#[doc(hidden)]
pub struct _PCTL;
#[doc = "`read()` method returns [pctl::R](pctl::R) reader structure"]
impl crate::Readable for PCTL {}
#[doc = "`write(|w| ..)` method takes [pctl::W](pctl::W) writer structure"]
impl crate::Writable for PCTL {}
#[doc = "This register is not used in cc3xx. equivalant register exsist outside GPIO IP (refer PAD*_config register in the shared comn space) 0x4000 552C 0x4000 652C 0x4000 752C 0x4002 452C GPIO Port Control (GPIOPCTL)@@ offset 0x52C The GPIOPCTL register is used in conjunction with the GPIOAFSEL register and selects the specific peripheral signal for each GPIO pin when using the alternate function mode. Most bits in the GPIOAFSEL register are cleared on reset@@ therefore most GPIO pins are configured as GPIOs by default. When a bit is set in the GPIOAFSEL register@@ the corresponding GPIO signal is controlled by an associated peripheral. The GPIOPCTL register selects one out of a set of peripheral functions for each GPIO@@ providing additional flexibility in signal definition."]
pub mod pctl;
#[doc = "This register is not used in cc3xx. ADC trigger via GPIO is not supported. 0x4000 5530 0x4000 6530 0x4000 7530 0x4002 4530 GPIO ADC Control (GPIOADCCTL)@@ offset 0x530 This register is used to configure a GPIO pin as a source for the ADC trigger. Note that if the Port B GPIOADCCTL register is cleared@@ PB4 can still be used as an external trigger for the ADC. This is a legacy mode which allows code written for previous Stellaris devices to operate on this microcontroller.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [adcctl](adcctl) module"]
pub type ADCCTL = crate::Reg<u32, _ADCCTL>;
#[allow(missing_docs)]
#[doc(hidden)]
pub struct _ADCCTL;
#[doc = "`read()` method returns [adcctl::R](adcctl::R) reader structure"]
impl crate::Readable for ADCCTL {}
#[doc = "`write(|w| ..)` method takes [adcctl::W](adcctl::W) writer structure"]
impl crate::Writable for ADCCTL {}
#[doc = "This register is not used in cc3xx. ADC trigger via GPIO is not supported. 0x4000 5530 0x4000 6530 0x4000 7530 0x4002 4530 GPIO ADC Control (GPIOADCCTL)@@ offset 0x530 This register is used to configure a GPIO pin as a source for the ADC trigger. Note that if the Port B GPIOADCCTL register is cleared@@ PB4 can still be used as an external trigger for the ADC. This is a legacy mode which allows code written for previous Stellaris devices to operate on this microcontroller."]
pub mod adcctl;
#[doc = "0x4000 5534 0x4000 6534 0x4000 7534 0x4002 4534 GPIO DMA Control (GPIODMACTL)@@ offset 0x534 This register is used to configure a GPIO pin as a source for the ?DMA trigger.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dmactl](dmactl) module"]
pub type DMACTL = crate::Reg<u32, _DMACTL>;
#[allow(missing_docs)]
#[doc(hidden)]
pub struct _DMACTL;
#[doc = "`read()` method returns [dmactl::R](dmactl::R) reader structure"]
impl crate::Readable for DMACTL {}
#[doc = "`write(|w| ..)` method takes [dmactl::W](dmactl::W) writer structure"]
impl crate::Writable for DMACTL {}
#[doc = "0x4000 5534 0x4000 6534 0x4000 7534 0x4002 4534 GPIO DMA Control (GPIODMACTL)@@ offset 0x534 This register is used to configure a GPIO pin as a source for the ?DMA trigger."]
pub mod dmactl;
#[doc = "0x4000 5538 0x4000 6538 0x4000 7538 0x4002 4538 GPIO Select Interrupt (GPIOSI)@@ offset 0x538 This register is used to enable individual interrupts for each pin. Note: This register is only available on Port P and Port Q.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [si](si) module"]
pub type SI = crate::Reg<u32, _SI>;
#[allow(missing_docs)]
#[doc(hidden)]
pub struct _SI;
#[doc = "`read()` method returns [si::R](si::R) reader structure"]
impl crate::Readable for SI {}
#[doc = "`write(|w| ..)` method takes [si::W](si::W) writer structure"]
impl crate::Writable for SI {}
#[doc = "0x4000 5538 0x4000 6538 0x4000 7538 0x4002 4538 GPIO Select Interrupt (GPIOSI)@@ offset 0x538 This register is used to enable individual interrupts for each pin. Note: This register is only available on Port P and Port Q."]
pub mod si;
#[doc = "0x4000 5FD0 0x4000 6FD0 0x4000 7FD0 0x4002 4FD0 GPIO Peripheral Identification 4 (GPIOPeriphID4)@@ offset 0xFD0 The GPIOPeriphID4@@ GPIOPeriphID5@@ GPIOPeriphID6@@ and GPIOPeriphID7 registers can conceptually be treated as one 32-bit register; each register contains eight bits of the 32-bit register@@ used by software to identify the peripheral.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [periphid4](periphid4) module"]
pub type PERIPHID4 = crate::Reg<u32, _PERIPHID4>;
#[allow(missing_docs)]
#[doc(hidden)]
pub struct _PERIPHID4;
#[doc = "`read()` method returns [periphid4::R](periphid4::R) reader structure"]
impl crate::Readable for PERIPHID4 {}
#[doc = "`write(|w| ..)` method takes [periphid4::W](periphid4::W) writer structure"]
impl crate::Writable for PERIPHID4 {}
#[doc = "0x4000 5FD0 0x4000 6FD0 0x4000 7FD0 0x4002 4FD0 GPIO Peripheral Identification 4 (GPIOPeriphID4)@@ offset 0xFD0 The GPIOPeriphID4@@ GPIOPeriphID5@@ GPIOPeriphID6@@ and GPIOPeriphID7 registers can conceptually be treated as one 32-bit register; each register contains eight bits of the 32-bit register@@ used by software to identify the peripheral."]
pub mod periphid4;
#[doc = "0x4000 5FD4 0x4000 6FD4 0x4000 7FD4 0x4002 4FD4 GPIO Peripheral Identification 5 (GPIOPeriphID5)@@ offset 0xFD4 The GPIOPeriphID4@@ GPIOPeriphID5@@ GPIOPeriphID6@@ and GPIOPeriphID7 registers can conceptually be treated as one 32-bit register; each register contains eight bits of the 32-bit register@@ used by software to identify the peripheral.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [periphid5](periphid5) module"]
pub type PERIPHID5 = crate::Reg<u32, _PERIPHID5>;
#[allow(missing_docs)]
#[doc(hidden)]
pub struct _PERIPHID5;
#[doc = "`read()` method returns [periphid5::R](periphid5::R) reader structure"]
impl crate::Readable for PERIPHID5 {}
#[doc = "`write(|w| ..)` method takes [periphid5::W](periphid5::W) writer structure"]
impl crate::Writable for PERIPHID5 {}
#[doc = "0x4000 5FD4 0x4000 6FD4 0x4000 7FD4 0x4002 4FD4 GPIO Peripheral Identification 5 (GPIOPeriphID5)@@ offset 0xFD4 The GPIOPeriphID4@@ GPIOPeriphID5@@ GPIOPeriphID6@@ and GPIOPeriphID7 registers can conceptually be treated as one 32-bit register; each register contains eight bits of the 32-bit register@@ used by software to identify the peripheral."]
pub mod periphid5;
#[doc = "0x4000 5FD8 0x4000 6FD8 0x4000 7FD8 0x4002 4FD8 GPIO Peripheral Identification 6 (GPIOPeriphID6)@@ offset 0xFD8 The GPIOPeriphID4@@ GPIOPeriphID5@@ GPIOPeriphID6@@ and GPIOPeriphID7 registers can conceptually be treated as one 32-bit register; each register contains eight bits of the 32-bit register@@ used by software to identify the peripheral.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [periphid6](periphid6) module"]
pub type PERIPHID6 = crate::Reg<u32, _PERIPHID6>;
#[allow(missing_docs)]
#[doc(hidden)]
pub struct _PERIPHID6;
#[doc = "`read()` method returns [periphid6::R](periphid6::R) reader structure"]
impl crate::Readable for PERIPHID6 {}
#[doc = "`write(|w| ..)` method takes [periphid6::W](periphid6::W) writer structure"]
impl crate::Writable for PERIPHID6 {}
#[doc = "0x4000 5FD8 0x4000 6FD8 0x4000 7FD8 0x4002 4FD8 GPIO Peripheral Identification 6 (GPIOPeriphID6)@@ offset 0xFD8 The GPIOPeriphID4@@ GPIOPeriphID5@@ GPIOPeriphID6@@ and GPIOPeriphID7 registers can conceptually be treated as one 32-bit register; each register contains eight bits of the 32-bit register@@ used by software to identify the peripheral."]
pub mod periphid6;
#[doc = "0x4000 5FDC 0x4000 6FDC 0x4000 7FDC 0x4002 4FDC GPIO Peripheral Identification 7 (GPIOPeriphID7)@@ offset 0xFDC The GPIOPeriphID4@@ GPIOPeriphID5@@ GPIOPeriphID6@@ and GPIOPeriphID7 registers can conceptually be treated as one 32-bit register; each register contains eight bits of the 32-bit register@@ used by software to identify the peripheral.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [periphid7](periphid7) module"]
pub type PERIPHID7 = crate::Reg<u32, _PERIPHID7>;
#[allow(missing_docs)]
#[doc(hidden)]
pub struct _PERIPHID7;
#[doc = "`read()` method returns [periphid7::R](periphid7::R) reader structure"]
impl crate::Readable for PERIPHID7 {}
#[doc = "`write(|w| ..)` method takes [periphid7::W](periphid7::W) writer structure"]
impl crate::Writable for PERIPHID7 {}
#[doc = "0x4000 5FDC 0x4000 6FDC 0x4000 7FDC 0x4002 4FDC GPIO Peripheral Identification 7 (GPIOPeriphID7)@@ offset 0xFDC The GPIOPeriphID4@@ GPIOPeriphID5@@ GPIOPeriphID6@@ and GPIOPeriphID7 registers can conceptually be treated as one 32-bit register; each register contains eight bits of the 32-bit register@@ used by software to identify the peripheral."]
pub mod periphid7;
#[doc = "0x4000 5FE0 0x4000 6FE0 0x4000 7FE0 0x4002 4FE0 GPIO Peripheral Identification 0 (GPIOPeriphID0)@@ offset 0xFE0 The GPIOPeriphID0@@ GPIOPeriphID1@@ GPIOPeriphID2@@ and GPIOPeriphID3 registers can conceptually be treated as one 32-bit register; each register contains eight bits of the 32-bit register@@ used by software to identify the peripheral.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [periphid0](periphid0) module"]
pub type PERIPHID0 = crate::Reg<u32, _PERIPHID0>;
#[allow(missing_docs)]
#[doc(hidden)]
pub struct _PERIPHID0;
#[doc = "`read()` method returns [periphid0::R](periphid0::R) reader structure"]
impl crate::Readable for PERIPHID0 {}
#[doc = "`write(|w| ..)` method takes [periphid0::W](periphid0::W) writer structure"]
impl crate::Writable for PERIPHID0 {}
#[doc = "0x4000 5FE0 0x4000 6FE0 0x4000 7FE0 0x4002 4FE0 GPIO Peripheral Identification 0 (GPIOPeriphID0)@@ offset 0xFE0 The GPIOPeriphID0@@ GPIOPeriphID1@@ GPIOPeriphID2@@ and GPIOPeriphID3 registers can conceptually be treated as one 32-bit register; each register contains eight bits of the 32-bit register@@ used by software to identify the peripheral."]
pub mod periphid0;
#[doc = "0x4000 5FE4 0x4000 6FE4 0x4000 7FE4 0x4002 4FE4 GPIO Peripheral Identification 1 (GPIOPeriphID1)@@ offset 0xFE4 The GPIOPeriphID0@@ GPIOPeriphID1@@ GPIOPeriphID2@@ and GPIOPeriphID3 registers can conceptually be treated as one 32-bit register; each register contains eight bits of the 32-bit register@@ used by software to identify the peripheral.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [periphid1](periphid1) module"]
pub type PERIPHID1 = crate::Reg<u32, _PERIPHID1>;
#[allow(missing_docs)]
#[doc(hidden)]
pub struct _PERIPHID1;
#[doc = "`read()` method returns [periphid1::R](periphid1::R) reader structure"]
impl crate::Readable for PERIPHID1 {}
#[doc = "`write(|w| ..)` method takes [periphid1::W](periphid1::W) writer structure"]
impl crate::Writable for PERIPHID1 {}
#[doc = "0x4000 5FE4 0x4000 6FE4 0x4000 7FE4 0x4002 4FE4 GPIO Peripheral Identification 1 (GPIOPeriphID1)@@ offset 0xFE4 The GPIOPeriphID0@@ GPIOPeriphID1@@ GPIOPeriphID2@@ and GPIOPeriphID3 registers can conceptually be treated as one 32-bit register; each register contains eight bits of the 32-bit register@@ used by software to identify the peripheral."]
pub mod periphid1;
#[doc = "0x4000 5FE8 0x4000 6FE8 0x4000 7FE8 0x4002 4FE8 GPIO Peripheral Identification 2 (GPIOPeriphID2)@@ offset 0xFE8 The GPIOPeriphID0@@ GPIOPeriphID1@@ GPIOPeriphID2@@ and GPIOPeriphID3 registers can conceptually be treated as one 32-bit register; each register contains eight bits of the 32-bit register@@ used by software to identify the peripheral.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [periphid2](periphid2) module"]
pub type PERIPHID2 = crate::Reg<u32, _PERIPHID2>;
#[allow(missing_docs)]
#[doc(hidden)]
pub struct _PERIPHID2;
#[doc = "`read()` method returns [periphid2::R](periphid2::R) reader structure"]
impl crate::Readable for PERIPHID2 {}
#[doc = "`write(|w| ..)` method takes [periphid2::W](periphid2::W) writer structure"]
impl crate::Writable for PERIPHID2 {}
#[doc = "0x4000 5FE8 0x4000 6FE8 0x4000 7FE8 0x4002 4FE8 GPIO Peripheral Identification 2 (GPIOPeriphID2)@@ offset 0xFE8 The GPIOPeriphID0@@ GPIOPeriphID1@@ GPIOPeriphID2@@ and GPIOPeriphID3 registers can conceptually be treated as one 32-bit register; each register contains eight bits of the 32-bit register@@ used by software to identify the peripheral."]
pub mod periphid2;
#[doc = "0x4000 5FEC 0x4000 6FEC 0x4000 7FEC 0x4002 4FEC GPIO Peripheral Identification 3 (GPIOPeriphID3)@@ offset 0xFEC The GPIOPeriphID0@@ GPIOPeriphID1@@ GPIOPeriphID2@@ and GPIOPeriphID3 registers can conceptually be treated as one 32-bit register; each register contains eight bits of the 32-bit register@@ used by software to identify the peripheral.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [periphid3](periphid3) module"]
pub type PERIPHID3 = crate::Reg<u32, _PERIPHID3>;
#[allow(missing_docs)]
#[doc(hidden)]
pub struct _PERIPHID3;
#[doc = "`read()` method returns [periphid3::R](periphid3::R) reader structure"]
impl crate::Readable for PERIPHID3 {}
#[doc = "`write(|w| ..)` method takes [periphid3::W](periphid3::W) writer structure"]
impl crate::Writable for PERIPHID3 {}
#[doc = "0x4000 5FEC 0x4000 6FEC 0x4000 7FEC 0x4002 4FEC GPIO Peripheral Identification 3 (GPIOPeriphID3)@@ offset 0xFEC The GPIOPeriphID0@@ GPIOPeriphID1@@ GPIOPeriphID2@@ and GPIOPeriphID3 registers can conceptually be treated as one 32-bit register; each register contains eight bits of the 32-bit register@@ used by software to identify the peripheral."]
pub mod periphid3;
#[doc = "0x4000 5FF0 0x4000 6FF0 0x4000 7FF0 0x4002 4FF0 GPIO PrimeCell Identification 0 (GPIOPCellID0)@@ offset 0xFF0 The GPIOPCellID0@@ GPIOPCellID1@@ GPIOPCellID2@@ and GPIOPCellID3 registers are four 8-bit wide registers@@ that can conceptually be treated as one 32-bit register. The register is used as a standard cross-peripheral identification system.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pcellid0](pcellid0) module"]
pub type PCELLID0 = crate::Reg<u32, _PCELLID0>;
#[allow(missing_docs)]
#[doc(hidden)]
pub struct _PCELLID0;
#[doc = "`read()` method returns [pcellid0::R](pcellid0::R) reader structure"]
impl crate::Readable for PCELLID0 {}
#[doc = "`write(|w| ..)` method takes [pcellid0::W](pcellid0::W) writer structure"]
impl crate::Writable for PCELLID0 {}
#[doc = "0x4000 5FF0 0x4000 6FF0 0x4000 7FF0 0x4002 4FF0 GPIO PrimeCell Identification 0 (GPIOPCellID0)@@ offset 0xFF0 The GPIOPCellID0@@ GPIOPCellID1@@ GPIOPCellID2@@ and GPIOPCellID3 registers are four 8-bit wide registers@@ that can conceptually be treated as one 32-bit register. The register is used as a standard cross-peripheral identification system."]
pub mod pcellid0;
#[doc = "0x4000 5FF4 0x4000 6FF4 0x4000 7FF4 0x4002 4FF4 GPIO PrimeCell Identification 1 (GPIOPCellID1)@@ offset 0xFF4 The GPIOPCellID0@@ GPIOPCellID1@@ GPIOPCellID2@@ and GPIOPCellID3 registers are four 8-bit wide registers@@ that can conceptually be treated as one 32-bit register. The register is used as a standard cross-peripheral identification system.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pcellid1](pcellid1) module"]
pub type PCELLID1 = crate::Reg<u32, _PCELLID1>;
#[allow(missing_docs)]
#[doc(hidden)]
pub struct _PCELLID1;
#[doc = "`read()` method returns [pcellid1::R](pcellid1::R) reader structure"]
impl crate::Readable for PCELLID1 {}
#[doc = "`write(|w| ..)` method takes [pcellid1::W](pcellid1::W) writer structure"]
impl crate::Writable for PCELLID1 {}
#[doc = "0x4000 5FF4 0x4000 6FF4 0x4000 7FF4 0x4002 4FF4 GPIO PrimeCell Identification 1 (GPIOPCellID1)@@ offset 0xFF4 The GPIOPCellID0@@ GPIOPCellID1@@ GPIOPCellID2@@ and GPIOPCellID3 registers are four 8-bit wide registers@@ that can conceptually be treated as one 32-bit register. The register is used as a standard cross-peripheral identification system."]
pub mod pcellid1;
#[doc = "0x4000 5FF8 0x4000 6FF8 0x4000 7FF8 0x4002 4FF8 GPIO PrimeCell Identification 2 (GPIOPCellID2)@@ offset 0xFF8 The GPIOPCellID0@@ GPIOPCellID1@@ GPIOPCellID2@@ and GPIOPCellID3 registers are four 8-bit wide registers@@ that can conceptually be treated as one 32-bit register. The register is used as a standard cross-peripheral identification system.\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pcellid2](pcellid2) module"]
pub type PCELLID2 = crate::Reg<u32, _PCELLID2>;
#[allow(missing_docs)]
#[doc(hidden)]
pub struct _PCELLID2;
#[doc = "`read()` method returns [pcellid2::R](pcellid2::R) reader structure"]
impl crate::Readable for PCELLID2 {}
#[doc = "`write(|w| ..)` method takes [pcellid2::W](pcellid2::W) writer structure"]
impl crate::Writable for PCELLID2 {}
#[doc = "0x4000 5FF8 0x4000 6FF8 0x4000 7FF8 0x4002 4FF8 GPIO PrimeCell Identification 2 (GPIOPCellID2)@@ offset 0xFF8 The GPIOPCellID0@@ GPIOPCellID1@@ GPIOPCellID2@@ and GPIOPCellID3 registers are four 8-bit wide registers@@ that can conceptually be treated as one 32-bit register. The register is used as a standard cross-peripheral identification system."]
pub mod pcellid2;
#[doc = "0x4000 5FFC 0x4000 6FFC 0x4000 7FFC 0x4002 4FFC GPIO PrimeCell Identification 3 (GPIOPCellID3)@@ offset 0xFFC The GPIOPCellID0@@ GPIOPCellID1@@ GPIOPCellID2@@ and GPIOPCellID3 registers are four 8-bit wide registers@@ that can conceptually be treated as one 32-bit register. The register is used as a standard cross-peripheral identification system.0xb1 ****************************************************************************\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pcellid3](pcellid3) module"]
pub type PCELLID3 = crate::Reg<u32, _PCELLID3>;
#[allow(missing_docs)]
#[doc(hidden)]
pub struct _PCELLID3;
#[doc = "`read()` method returns [pcellid3::R](pcellid3::R) reader structure"]
impl crate::Readable for PCELLID3 {}
#[doc = "`write(|w| ..)` method takes [pcellid3::W](pcellid3::W) writer structure"]
impl crate::Writable for PCELLID3 {}
#[doc = "0x4000 5FFC 0x4000 6FFC 0x4000 7FFC 0x4002 4FFC GPIO PrimeCell Identification 3 (GPIOPCellID3)@@ offset 0xFFC The GPIOPCellID0@@ GPIOPCellID1@@ GPIOPCellID2@@ and GPIOPCellID3 registers are four 8-bit wide registers@@ that can conceptually be treated as one 32-bit register. The register is used as a standard cross-peripheral identification system.0xb1 ****************************************************************************"]
pub mod pcellid3;
